# Today-I-Learned

##### Date: 2025-11-16

# 1️⃣ 오늘 배운 것
- 동적 계획(DP)를 이용한 최소 연산 알고리즘
- - -
# 2️⃣ 참고 문제 / 자료
1. 백준_2839번: 설탕 배달
- - -
# 3️⃣ 정리
  ## 1. 백준_2839번_설탕 배달
  ### 🖥 사용 개념
  - 동적 계획(DP)를 이용한 최소 연산 알고리즘
- - -
  ### 🛠 개념 정리
  **1. '동적 계획(DP)를 이용한 최소 연산 알고리즘'**
  * 1차원 DP 알고리즘
      - 가중치 1짜리 최단거리와 같은 구조를 가짐.
  * n이 존재하고, 두 가지 수가 주어지면서 연산을 통해 n과 동일한 수를 만들 수 있는 최소 연산이 필요할 때 사용.
      - ex) n = 11이고, 3과 5가 주어질 때 해당 알고리즘을 이용.
  * dp 배열의 모든 칸에 INF(연산에 영향을 주지 않는 큰 수)를 채워 넣은 후, 조건문을 만족하면 횟수를 기록하는 식으로 최소 횟수 연산.
      - if문을 2개 사용해서 2가지 조건문을 모두 만족하더라도 순서에 의해 최소 횟수만 기록이 됨.
          - 앞의 조건문은 주어지는 수 중 작은 수를 넣어야 함.
          - 예를 들어 3과 5가 주어진 경우, 3이 앞의 조건문에 사용되고, 5가 그 다음 조건문에 사용되는 방식.
  * k개의 수를 이용하게 된다면 k개 만큼의 조건문을 만들면 되자만, 수가 많다면 배열을 하나 만든 후, 반복문으로 조건문을 단순하게 바꾸는게 가독성이 좋음.
- - -
<pre>
<code>
        int[] dp = new int[n + 1];
        Arrays.fill(dp, INF);
        if(n <= 5){
            if (n == 3 || n == 5) System.out.println(1);
            else System.out.println(-1);
        } else{
            dp[0] = 0;
            for (int i = 1; i <= n; i++){
                dp[i] = INF;
                if (i >= 3 && dp[i - 3] != INF){
                    dp[i] = Math.min(dp[i], dp[i - 3] + 1);
                }
                if (i >= 5 && dp[i - 5] != INF){
                    dp[i] = Math.min(dp[i], dp[i - 5] + 1);
                }
            }
            if (dp[n] == INF) System.out.println(-1);
            else System.out.println(dp[n]);
        }
</code>
</pre>
- - -
  ### 🔍 해결 방법
  - 해당 알고리즘을 처음에 몰라서 그저 5로 먼저 나눈 뒤 나머지를 3으로 나누는 방식으로 코드를 짰었음.
  - 하지만 해당 코드는 일부에서만 결과값을 만족했기 때문에 해결 코드로 적합하지 않았음.
  - 해당 알고리즘은 그런 부족한 부분을 채워줄 수 있는 알고리즘.
  - 배열을 이용해서 INF 또는 조건문 만족 시 횟수가 기록되는 방식으로 동전 교환 문제 해결 방법과 동일함.
- - -
  ### 🤔 아쉬운 점
  * 알고리즘과 자료구조 부분의 지식이 많이 부족하다는 걸 느꼈음.
  * 이전부터 계속 나오는 문제의 해결 자체를 스스로 해내지 못했기 때문에 알고리즘과 자료구조 부분을 좀 더 공부해야 할 것 같다.
- - -
  ### 🔔 전체 코드
  <pre>
  <code>
    import java.io.*;
    import java.util.*;
    
    public class a_2839{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        static final int INF = 1_000_000_000;
        public void run() throws IOException{
            int n = Integer.parseInt(br.readLine());
            int[] dp = new int[n + 1];
            Arrays.fill(dp, INF);
            if(n <= 5){
                if (n == 3 || n == 5) System.out.println(1);
                else System.out.println(-1);
            } else{
                dp[0] = 0;
                for (int i = 1; i <= n; i++){
                    dp[i] = INF;
                    if (i >= 3 && dp[i - 3] != INF){
                        dp[i] = Math.min(dp[i], dp[i - 3] + 1);
                    }
                    if (i >= 5 && dp[i - 5] != INF){
                        dp[i] = Math.min(dp[i], dp[i - 5] + 1);
                    }
                }
                if (dp[n] == INF) System.out.println(-1);
                else System.out.println(dp[n]);
            }
            br.close();
        }
        public static void main(String[] args) throws IOException{
            try{
                new a_2839().run();
            } catch (IOException e){
                System.err.println(e.getMessage());
            }
        }
    }
  </code>
  </pre>
- - -
