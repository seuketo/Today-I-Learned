# Today-I-Learned

##### Date: 2025-04-11 (Day 2)

## 1️⃣ 오늘 배운 것
오늘은 백준을 통해 알고리즘 문제를 해결하였다.

## 2️⃣ 참고 문제, 혹은 자료
1. 백준_10814번: 나이순 정렬
2.

## 3️⃣ 정리
  ### 1. 백준_10814번: 나이순 정렬
  #### 🖥 사용 개념
  - JAVA - 객체
  - JAVA - 람다식
  - JAVA - Comparator

  #### 🛠 개념 정리
  **1. 람다식**
  * 일체 객체로, 매개변수를 동적으로 설정함으로써 매개변수의 입력값에 따른 재사용이 가능함.
  * 람다식은 자동 추론이 가능하다.
    - 자동 추론은 사용자가 임의로 입력한 데이터 혹은 매개변수를 사용한 문장을 토대로 해당 데이터의 데이터 타입 혹은 매개변수가 무엇을 가리키는지 추론하여 적용하는 것을 말함.
    - **람다식을 통해 해당 개념을 최초로 알게 됨.**
  * 객체를 대상으로 사용할 경우, 예시는 다음과 같다.
<pre>
<code>
arr.sort(Comparator.comparingInt(m -> m.age));
</code>
</pre>
  **2. Comparator**
  * 두 개의 객체를 비교해서 정렬 기준을 제공하는 인터페이스.
  * Arrays.sort(), Collections.sort() 등에 자주 쓰이며, 예시는 다음과 같다.
<pre>
<code>
// 해당 구문은 백준_1181번: 단어정렬 문제에서 작성했던 해답 코드 일부와 동일함.
// 해당 문제는 길이를 기준으로 먼저 오름차순 정렬 후, 동일한 길이일 경우 사전순으로 정렬해야함.
/* 
  Comparator<String>()는 내부적으로 compare() 메소드를 정렬이 끝날때까지 계속 반복함.
  람다식과 연계했을 때를 예시로 든다면, 만약 (a, b) -> b - a라고 정의한다면
    양수 = b가 우선 (자리 변경)
    0 = 그대로
    음수 = a가 우선
*/
// arr 배열을 Comparator 인터페이스를 선언함과 동시에 정렬 기준으로 넣음.
Collections.sort(arr, new Comparator<String>(){
  // @Override를 통해 compare()를 재정의.
  @Override
    public int compare(String a, String b){
  // 1. 길이 먼저 정렬
      if (a.length() != b.length()){
        return a.length() - b.length(); 
      }
  // 2. 동일한 길이일 경우, 사전순으로 정렬
      return a.compareTo(b);
    }
});
</code>
</pre>
    
  #### 📃 문제 정리
  - 나이와 이름이 가입한 순서대로 주어지면 나이를 기준으로 오름차순 정렬 후, 동일한 나이의 경우 가입한 순서를 기준으로 정렬하는 문제.
  - 정렬 기준이 2가지인데다가 특정 기준의 경우 나이가 동일한 경우에만 적용해야 함.
  #### 🔍 해결 방법
  - **Comparator**와 **객체**를 이용해서 기준 순서를 결정함.
  - **람다식**으로 코드의 단순화, 재활용이 가능한 코드 작성.
  #### 🔑 알게된 코드
  - 조합 코드를 활용할 수 있는 방법에 대해 알게 되었다.
  <pre>
  <code>
        for (int i = 0; i < n; i++){
            st = new StringTokenizer(br.readLine());
            arr.add(new Member(Integer.parseInt(st.nextToken()), st.nextToken()));
        }
        arr.sort(Comparator.comparingInt(m -> m.age));
        for (Member m : arr) System.out.println(m.age + " " + m.name);
  </code>
  </pre>
