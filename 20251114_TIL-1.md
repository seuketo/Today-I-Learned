# Today-I-Learned

##### Date: 2025-11-14

## 1️⃣ 오늘 배운 것
백준 문제 풀이를 통해 다음과 같은 요소에 관한 개념을 정리하였다.
- '에라토스테네스의 체'에 관한 불확실했던 개념 정리.
- 자연수가 주어졌을 때, 얻을 수 있는 생성자 중 가장 작은 수 구하기
- - -
## 2️⃣ 참고 문제, 혹은 자료
1. 백준_1978번: 소수 찾기
2. 백준_2231번: 분해합
- - -
## 3️⃣ 정리
  ### 1. 백준_1978번: 소수 찾기
  #### 🖥 사용 개념
  - '에라토스테네스의 체'
- - -
  #### 🛠 개념 정리
  **1. '에라토스테네스의 체'**
  * 수열에서 소수를 구하는 알고리즘.
  * 수의 범위가 기재된 경우 0부터 해당 범위까지의 수들 중에서 boolean[]을 통해 소수인지 아닌지 전처리에서 구별함.
  * 만약 수의 범위(N)가 1000인 경우, boolean 배열의 isPrime을 N+1 크기만큼 생성해서 모든 값을 true로 초기화 후, 0과 1 제외, 짝수 제외, 이후 나오는 수 중 가장 작은 수는 소수로 가정하고 해당 수의 배수는 모두 제외하는 방식.
  * 개수를 얻을 경우엔 조건문을 통해 true인 경우만 count, 최소값을 얻고 싶다면 조건문을 통해 최초로 얻는 값을 출력.
  * 만약 난수로 표시된 경우, 해당 값을 조건문으로 넣어 isPrime에서 해당 값이 true인 경우에만 원하는 출력값을 얻을 수 있도록 함.
<pre>
<code>
  public static boolean[] sieve(int n){
        // return값 생성. run() 메소드에서 isPrime 배열을 선언했기 때문.
        boolean[] isPrime = new boolean[n + 1];

        // isPrime 배열 모든 요소값을 true로 설정.
        for (int i = 0; i < n + 1; i++) isPrime[i] = true;

        // n이 1개만 존재할 경우, 2개만 존재할 경우를 생각해서 if문 포함. 0과 1 제외.
        if (n >= 0) isPrime[0] = false;
        if (n >= 1) isPrime[1] = false;

        // 루트 n값까지 돌려서 isPrime 배열 속 i번째 값이 true면 조건문 진입. 2부터 시작함.
        int limit = (int) Math.sqrt(n);
        for (int i = 2; i < limit; i++){
            // 2의 경우 true이기 떄문에 진입, 2의 배수 모두 제외.
            // 이후 조건문에 진입하는 값이 true라면 그 수의 모든 배수는 제외됨.
            if (isPrime[i]){
                for (int j = i * i; j <= n; j += i){
                    isPrime[j] = false;
                }
            }
        }
        return isPrime;
  }
</code>
</pre>
- - -
  #### 🔍 해결 방법
  1. '에라토스테네스의 체'을 이용해서 0부터 입력될 수 있는 수의 범위까지 얻을 수 있는 모든 자연수의 소수 여부를 판별할 수 있는 함수를 전처리로 처리한 후, 원하는 출력값을 얻을 수 있도록 if(isPrime[index])를 활용해서 얻는 방법.
  2. '개별 판별 방식'을 활용해서 일일이 소수 구별 방식을 활용하는 방법. (0과 1일 경우 제외, 짝수일 경우 제외, √(최대 범위) 까지 반복해서 해당 수와 나눴을 때 나눠지는 수가 있는 경우 제외.) 
  #### 🔔 전체 코드
  <pre>
  <code>
  import java.util.*;
  import java.io.*;
  
  public class a_1978{
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      StringTokenizer st;
      public static boolean[] sieve(int n){
          // return값 생성. run() 메소드에서 isPrime 배열을 선언했기 때문.
          boolean[] isPrime = new boolean[n + 1];
  
          // isPrime 배열 모든 요소값을 true로 설정.
          for (int i = 0; i < n + 1; i++) isPrime[i] = true;
  
          // n이 1개만 존재할 경우, 2개만 존재할 경우를 생각해서 if문 포함. 0과 1 제외.
          if (n >= 0) isPrime[0] = false;
          if (n >= 1) isPrime[1] = false;
  
          // 루트 n값까지 돌려서 isPrime 배열 속 i번째 값이 true면 조건문 진입. 2부터 시작함.
          int limit = (int) Math.sqrt(n);
          for (int i = 2; i < limit; i++){
              // 2의 경우 true이기 떄문에 진입, 2의 배수 모두 제외.
              // 이후 조건문에 진입하는 값이 true라면 그 수의 모든 배수는 제외됨.
              if (isPrime[i]){
                  for (int j = i * i; j <= n; j += i){
                      isPrime[j] = false;
                  }
              }
          }
          return isPrime;
      }
  
      public void run() throws IOException{
          int n = Integer.parseInt(br.readLine());
          st = new StringTokenizer(br.readLine());
          
          boolean[] isPrime = sieve(1000);
  
          int count = 0;
          for (int i = 0; i < n; i++){
              int num = Integer.parseInt(st.nextToken());
              if (isPrime[num]){
                  count++;
              }
          }
          System.out.println(count);
          br.close();
      }
      public static void main(String[] args) throws IOException{
          try{
              new a_1978().run();
          } catch (IOException e){
              System.err.println(e.getMessage());
          }
      }
  }
  </code>
  </pre>
- - -
  ### 2. 백준_2213번: 분해합
  #### 🖥 사용 개념
  - '분해합과 생성자'
- - -
  #### 🛠 개념 정리
  **1. '분해합과 생성자'**
  * 어떤 자연수 M의 분해합 T = (M + 자연수(M) 각 자리의 합).
  * T의 값이 어떤 자연수(N)과 같을 때, M = N의 생성자
  * 만약 어떤 자연수 N을 얻었을 때, 생성자의 범위는 다음과 같음.
      * N = M + (각 자리의 합) <= M + (9(각 자리마다 가질 수 있는 최대의 수) * d(N의 자리수)) => 최대로 얻을 수 있는 생성자
      * N - (9 * d) <= M => 최소로 얻을 수 있는 생성자
      * 어떤 자연수의 생성자이기 때문에 0과 음수는 가정하지 않음. 이런 경우 1로 전환.
  * 반복문을 이용해 최소 생성자와 최대 생성자를 구할 수 있음.
      * 최소 생성자
          * start = Math.max(1, N - (9 * d))
          * end = N - 1
          * i++
      * 최대 생성자
          * start = N - 1
          * end = Math.max(1, N - (9 * d))
          * i--
<pre>
<code>
      int start = Math.max(1, Integer.parseInt(N) - (9 * d)); //216 - 27 = 189
      if (start <= 0) start = 1;
      int sum = 0;
      int result = 0;
      for (int i = start; i < Integer.parseInt(N); i++){ //189 ~ 215
          sum = i;
          int value = i;
          while (value > 0){
              sum += value % 10;
              value /= 10;
          }
          if (sum == Integer.parseInt(N)) {
              result = i;
              break;
          } else if (sum != Integer.parseInt(N) && i == Integer.parseInt(N) - 1){
              result = 0;
              break;
          }
      }
</code>
</pre>
- - -
  #### 🔍 해결 방법
  - 해당 문제는 최소 생성자를 찾는 문제였기 때문에 개념에 기재한 코드를 활용해서 문제를 해결함. 최대의 경우 반복문의 조건을 반대로 해서 큰 수부터 내려오는 방식으로 찾으면 됨.
  #### 🔔 전체 코드
  <pre>
  <code>
    import java.io.*;
    public class a_2231{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        public void run() throws IOException{
            String N = br.readLine();
            int d = N.length();
            int start = Math.max(1, Integer.parseInt(N) - (9 * d)); //216 - 27 = 189
            if (start <= 0) start = 1;
            int sum = 0;
            int result = 0;
            for (int i = start; i < Integer.parseInt(N); i++){ //189 ~ 215
                sum = i;
                int value = i;
                while (value > 0){
                    sum += value % 10;
                    value /= 10;
                }
                if (sum == Integer.parseInt(N)) {
                    result = i;
                    break;
                } else if (sum != Integer.parseInt(N) && i == Integer.parseInt(N) - 1){
                    result = 0;
                    break;
                }
            }
            System.out.println(result);
            br.close();
        }
              
        public static void main(String[] args) throws IOException{
            try{
                new a_2231().run();
            } catch(IOException e){
                System.err.println(e.getMessage());
            }
        }
    }
  </code>
  </pre>
    
